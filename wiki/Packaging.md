# Packaging by CMake

### Procedure to make a tagged release

Github workflow CI should generate new binary packages on each git push, that is dev build with version  `0.3-dev`

`git tag  v0.3.0` or branch if necessary in the stable release stage.
`cd build && cmake -DPPP_VERSION_NAME="0.3.0"  -DCMAKE_BUILD_TYPE=Release .. && make -j4 && make package`
run the unit test, then manually upload the packages to github Release.

Docker will be used to generate binary package for more platforms

if version increases, edit 
+ `PROJECT_VERSION: "0.3-dev"`  in github workflow CI yml files 
+ PACKAGE_VERSION in project CMakeLists.txt
+ download link in Readme.md

## Introduction to CPack 

`cpack` configuration in CMakeLists.txt can generate ubuntu and fedora binary packages. 

Inside the build folder, run  `make package` to generate *.deb or *.rpm 

A all-in-one package include all (lib, bin, python module, headers).

Windows NSIS packaging is one package generator for cpack, but it is yet tested. Installation by conda for windows would be a better choice for C++ and Python API users.

`make install` enabled by `install()` cmake command, can also be used in conda packaging workflow. 

## binary and development files

- Binaries,  executables
- Headers,  by PUBLIC_HEADER DESTINATION include/Geom
- Library, shared libraries like `libpppGeom.so`
Note: may not work on windows

https://gitlab.kitware.com/cmake/community/wikis/doc/cpack/Component-Install-With-CPack
```cmake

set_target_properties(MyGeom PROPERTIES 
    PUBLIC_HEADER "${GEOM_HEADERS}")  # must use quote, otherwise only the first one

install(TARGETS MyGeom
  RUNTIME DESTINATION bin
  LIBRARY DESTINATION lib
  PUBLIC_HEADER DESTINATION include/ppp/Geom
  COMPONENT libraries
)
# can be renamed  `RENAME`  `PERMISSIONS`
```
## test data 

it is not decided where to install the test data, therefore, unit test can only run in build folder.

test data, 
test files,

Unit test can be turned off by CMake option `-DPPP_USE_TEST=OFF`

## Python module
### python site-package detection

`python3 -c "import sys; print(sys.path)"`

CMake can install all python stuff like utility scripts and extension module`ppp.so/ppp.pyd`, 

```cmake
    execute_process(
        COMMAND "${PYTHON_EXECUTABLE}" -c "if True:
          from distutils import sysconfig as sc
          print(sc.get_python_lib(prefix='', plat_specific=True))"
        OUTPUT_VARIABLE PYTHON_SITE
        OUTPUT_STRIP_TRAILING_WHITESPACE)
```

 `CPack`  should generate an all-in-one package (deb/rpm) including this python module.  This python module installation route needs more testing for different platform.

`conda` is another choice to support more platforms, by `make install` ppp.so should be installed to conda python' site, while it is not clear on Windows conda. 

### CMake's FindPython has Python_SITELIB, Python_SITEARCH

`Python_SITELIB` is Third-party platform independent installation directory.

Information returned by `distutils.sysconfig.get_python_lib(plat_specific=False,standard_lib=False)`.

```
Python_SITEARCH
```

`Python_SITELIB` is Third-party platform dependent installation directory.

Information returned by `distutils.sysconfig.get_python_lib(plat_specific=True,standard_lib=False)`.

### Generate python interface module `ppp`

The python interface module `ppp` gives API similar with C++, e.g. class `PipelineController`, via pybind11 wrapping C++ API.  It is a not a pure Python module, but C-extension module must be compiled with a specific python version. It means different installer is needed for python 3.6 and python3.7, even if they link to the same c++ shared libraries (libpppGeom.so).

Although cmake has generate python extension "ppp.*.so" on Linux, it targets only one python version detected by cmake. It should be possible to add cmake option to choose python versions, if multiple versions are installed. To specify the python version during cmake configuration.

`-DPython_EXECUTABLE=full_path_to_python`

Extra python interface module can be generated by `setup.py` for another version of Python,  after cmake has successfully compled the all C++ targets such as `pppGeom` shared library.

It is driven by `full_path_to_python setup.py  bdist_wheel` (implemented yet tested). 

Currently, there are 2 hardcoded paths in <../python/setup.py>
It is assumed, the binary building dir is the `build` folder in the repository source dir, (see how the variable `ppp_lib_dir` assigned in setup.py) just as the compiling instruction shown in <CompileOnLinux.md> If a different building dir is used, manually change that variable. 
Another assumption is `occt_include_dir = "/usr/include/opencascade"`, change it if necessary.

### if ppp module is not built, `geomPipeline.py` still works
when `ppp` module is not built/installed,  `geomPipeline.py` will start an external process to run the command `geomPipeline your_config.json`.

`geomPipeline.py` is pure python script, so `geomPipeline your_config.json` works for any version of CPython; the drawback is that c++ class's python wrapping is not available.

## Release

It is expected some binary packages will be generated by CI system on the hosting web.
Tutorial for manuall upload binary as release: https://docs.github.com/en/free-pro-team@latest/github/administering-a-repository/managing-releases-in-a-repository

Auto upload asset to Release can be done by  the github workflow CI script snippets: https://github.com/actions/upload-release-asset
see more on doc:  https://developer.github.com/v3/repos/releases/#upload-a-release-asset
It is based on RESTFUL API, e.g. `POST https://uploads.github.com/repos/octocat/Hello-World/releases/1/assets?name=foo.zip`

"Release endpoint" can be create by CI action `actions/create-release@v1`, or manually, to generate `browser_download_url` in the **UPLOAD** section
```yml
    - name: Create Release Packages after testing
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ github.ref }}
        release_name: Release ${{ github.ref }}
        draft: false
        prerelease: true
```

can be limtied to some version tag
```yaml
on:
  push:
    # Sequence of patterns matched against refs/tags
    tags:
    - 'v*' # Push events to matching v*, i.e. v1.0, v20.15.10
```

CI may control only tag commit should generate release?

github workflow CI script could be tested out locally: https://github.com/nektos/act

### native binary package for Linux: Ubuntu deb/ fedora rpm package

deb package of `parallel-preprocessor` a single binary python module,  it is supported by CPack in the project toplevel cmakelists.txt file. it is  made from `cpack` command based on cmake configuration. see wiki page for more details.



	#CPackRPM ignores CPACK_RPM_FILE_NAME. Must set two other vars instead, and they interfere
	#string( TOLOWER "${CPACK_PACKAGE_NAME}-${OCE_VERSION}_${CPACK_RPM_PACKAGE_ARCHITECTURE}.rpm" CPACK_OUTPUT_FILE_NAME )
	if( NOT CPACK_GENERATOR STREQUAL "RPM" )
		message( WARNING "Generating an RPM with other package type(s). Due to a bug in CPackRPM, the package will not get copied to the current directory. It will be found in _CPack_Packages/Linux/RPM, and other packages may fail to build." )
	else()
		#this variable is used by other packagers, don't set it unless RPM is built by itself.
		#set( CPACK_PACKAGE_FILE_NAME ${CPACK_OUTPUT_FILE_NAME} )
	endif()

If system-wide python3 (installed from official repository) is used, which can be confirmed by `which python3`,  this ded/rpm has the correct python module installed.

The generated package only works for specific Linux distro and version, it is expected only latest Ubuntu LTS and fedora packages will be generated by CI.
For other platforms, compiling from source 

### Documentation upload


### binary conda package (under-testing) for all platforms

Compiling parallel-preprocessor on windows with dependencies installed by conda-forge, has been confirmed working. Upload to conda-forge is yet configured.

The conda recipe is based on cmake build system. This will install all components (c++ headers, shared-libraries, python interface) to conda's installation directory.


### container like docker image
Compile and build in docker has been tested, adopted by UKAEA openMC workshop.

### deploy on HPC

Centos7 has been tested to compile.  Deployment on HPC without admin privilege is under-investigation. UKAEA HPC has centos 7.x OS.  Singularity image can be a choice for user installation, to maximize the multi-threading or MPI performance.